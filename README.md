#  Тестовое задание
## Решение
### 1.Даталогическая схема данных
![Даталогическая схема данных:](/assets/schema.png)
### 2. SQL запросы
2.1  
```sql
SELECT c.name, SUM(g.price * oi.quantity) as order_total 
FROM customers as c
JOIN orders o ON o.customer_id = c.id
JOIN order_items oi ON oi.order_id = o.id
JOIN goods g ON g.id = oi.good_id
GROUP BY c.id;
```
2.2   
```sql
SELECT 
    p.id AS parent_id,
    p.name AS parent_name,
    count(c.id) AS children_count
FROM categories p
JOIN categories c ON c.parent_id = p.id
WHERE p.parent_id IS NULL
GROUP BY p.id, p.name;
```
2.3  
2.3.1 Создаем view, чтобы не нужно было каждый раз писать один и тот же код
```sql
CREATE OR REPLACE VIEW top_5_goods_last_month AS
WITH RECURSIVE category_path AS (
    -- Базовый случай: берем все категории
    SELECT id, name, parent_id, id AS root_id, name AS root_name
    FROM categories
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- Рекурсия: спускаемся вниз, сохраняя имя корневого родителя
    SELECT c.id, c.name, c.parent_id, cp.root_id, cp.root_name
    FROM categories c
    JOIN category_path cp ON c.parent_id = cp.id
)
SELECT 
    g.name AS "Наименование товара",
    cp.root_name AS "Категория 1-го уровня",
    SUM(oi.quantity) AS "Общее количество"
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
JOIN goods g ON oi.goods_id = g.id
JOIN category_path cp ON g.category_id = cp.id
-- Фильтр за последний месяц от текущей даты
WHERE o.order_date >= CURRENT_DATE - INTERVAL '1 month'
GROUP BY g.id, g.name, cp.root_name
ORDER BY "Общее количество" DESC
LIMIT 5;
```
Когда нам понадобится отчёт, выборка 5-ти самых популярных товаров за последний месяц, запускаем скрипт:  
```sql
SELECT * FROM top_5_goods_last_month;
```
2.3.2 
Анализ текущей архитектуры (PostgreSQL + Docker) показывает, что при росте до тысяч заказов в день рекурсивные вычисления «на лету» станут узким местом.
#### 1. Оптимизация схемы данных
**А. Денормализация категории**  
Рекурсия (WITH RECURSIVE) в каждом запросе — это дорого.

**Решение:** Добавим в таблицу goods колонку root_category_id. Будем ее заполнять один раз при создании товара или смене категории.  
**Результат:** Поиск «Категории 1-го уровня» превращается из рекурсивного обхода дерева в простое чтение одной колонки.

**Б. Материализованные представления (Materialized Views)**
Отчет за месяц не обязательно должен быть точным до секунды.

**Решение:** Будем использовать MATERIALIZED VIEW вместо обычного VIEW.
**Команда:** 
```sql
REFRESH MATERIALIZED VIEW CONCURRENTLY top_5_goods_last_month; 
```
(запускаем по расписанию раз в час).
#### 2. Оптимизация индексов
Для текущего запроса критически важны составные индексы:

_Для заказов:_  
```sql
CREATE INDEX idx_orders_date_id ON orders (order_date DESC, id);
```
— ускорит фильтрацию по дате за месяц.  
_Для позиций:_
```sql
CREATE INDEX idx_oi_goods_qty ON order_items (goods_id, quantity);
 ```
— ускорит агрегацию SUM(quantity).

#### 3. Партиционирование (Partitioning)
При тысячах заказов в день таблица orders и order_items быстро разрастутся до миллионов строк.

**Решение:** Использовать Declarative Partitioning по полю order_date (по месяцам).  
**Результат:** PostgreSQL будет сканировать только партицию за текущий месяц, игнорируя гигабайты старых данных.    

#### 4.Настройки PostgreSQL в Docker
Стандартный образ Docker настроен на минимальное потребление ресурсов. Для нагрузки в docker-compose или postgresql.conf нужно увеличить:

shared_buffers: до 25-40% от RAM.  
work_mem: чтобы сортировка (ORDER BY) происходила в памяти, а не на диске.

### 3. Сервис. Инструкция по запуску сервиса
Заполните .env файл соответствующими значениями переменных   

Запуск сервиса:
```bash
docker compose up --build
```

## Задание

### 1.   Спроектировать схему БД.
Модель данных реляционная.  

**Сущности**  
1.1 Номенклатура (наименование, кол-во, цена)  
1.2. Каталог номенклатуры/Дерево категорий.
Необходимо хранить данные о категориях товара, при этом сами категории могут иметь неограниченный уровень вложенности
  
 ![Пример дерева категорий:](/assets/category1.png)

Схема данных категорий номенклатуры должна безболезненно позволять добавлять категории любого уровня вложенности. На этапе проектирования максимальный уровень вложенности неизвестен.  
1.3. Клиенты (наименование, адрес)  
1.4. Заказы покупателей. Необходимо предусмотреть возможность делать заказ из разного набора товаров.
Продумать схему БД, бизнес логику описывать не требуется.
### 2. Написать следующие SQL запросы:
 
2.1. Получение информации о сумме товаров заказанных под каждого клиента (Наименование клиента, сумма)  
2.2. Найти количество дочерних элементов первого уровня вложенности для категорий номенклатуры.  
2.3.  
    2.3.1. Написать текст запроса для отчета (view) «Топ-5 самых покупаемых товаров за последний месяц» (по количеству штук в заказах). В отчете должны быть: Наименование товара, Категория 1-го уровня, Общее количество проданных штук.  
    2.3.2. Проанализировать написанный в п. 2.3.1 запрос и структуру БД. Предложить варианты оптимизации этого запроса и общей схемы данных для повышения производительности системы в условиях роста данных (тысячи заказов в день).  
### 3. Написать сервис «Добавление товара в заказ» который работает по REST-API. Метод должен принимать ID заказа, ID номенклатуры и количество. Если товар уже есть в заказе, его количество должно увеличиваться, а не создаваться новая позиция. Если товара нет в наличии то должна возвращаться соответствующая ошибка. Стек -  любой фреймворк в пределах Python. Git репозиторий, контейнеризация, документация, и прочее — приветствуется.  

![Пример дерева категорий:](/assets/category2.png)  
 Результатом выполнения задания должна быть даталогическая схема данных, SQL запросы по пункту 2 и сервис по пункту 3.



