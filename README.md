#  Тестовое задание
## Решение
### 1.Даталогическая схема данных
![Даталогическая схема данных:](/assets/schema.png)
### 2. SQL запросы
2.1  
```sql
SELECT c.name, SUM(g.price * oi.quantity) as order_total 
FROM customers as c
JOIN orders o ON o.customer_id = c.id
JOIN order_items oi ON oi.order_id = o.id
JOIN goods g ON g.id = oi.good_id
GROUP BY c.id;
```
2.2   
```sql
SELECT 
    p.id AS parent_id,
    p.name AS parent_name,
    count(c.id) AS children_count
FROM categories p
JOIN categories c ON c.parent_id = p.id
WHERE p.parent_id IS NULL
GROUP BY p.id, p.name;
```
2.3  
2.3.1
```sql
CREATE OR REPLACE VIEW top_5_goods_last_month AS
WITH RECURSIVE category_path AS (
    -- Базовый случай: берем все категории
    SELECT id, name, parent_id, id AS root_id, name AS root_name
    FROM categories
    WHERE parent_id IS NULL
    
    UNION ALL
    
    -- Рекурсия: спускаемся вниз, сохраняя имя корневого родителя
    SELECT c.id, c.name, c.parent_id, cp.root_id, cp.root_name
    FROM categories c
    JOIN category_path cp ON c.parent_id = cp.id
)
SELECT 
    g.name AS "Наименование товара",
    cp.root_name AS "Категория 1-го уровня",
    SUM(oi.quantity) AS "Общее количество"
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
JOIN goods g ON oi.goods_id = g.id
JOIN category_path cp ON g.category_id = cp.id
-- Фильтр за последний месяц от текущей даты
WHERE o.order_date >= CURRENT_DATE - INTERVAL '1 month'
GROUP BY g.id, g.name, cp.root_name
ORDER BY "Общее количество" DESC
LIMIT 5;
```
### 3. Сервис
Заполните .env файл соответствующими значениями переменных   
Запуск сервиса
```bash

```

## Задание

### 1.   Спроектировать схему БД.
Модель данных реляционная.  

**Сущности**  
1.1 Номенклатура (наименование, кол-во, цена)  
1.2. Каталог номенклатуры/Дерево категорий.
Необходимо хранить данные о категориях товара, при этом сами категории могут иметь неограниченный уровень вложенности
  
 ![Пример дерева категорий:](/assets/category1.png)

Схема данных категорий номенклатуры должна безболезненно позволять добавлять категории любого уровня вложенности. На этапе проектирования максимальный уровень вложенности неизвестен.  
1.3. Клиенты (наименование, адрес)  
1.4. Заказы покупателей. Необходимо предусмотреть возможность делать заказ из разного набора товаров.
Продумать схему БД, бизнес логику описывать не требуется.
### 2. Написать следующие SQL запросы:
 
2.1. Получение информации о сумме товаров заказанных под каждого клиента (Наименование клиента, сумма)  
2.2. Найти количество дочерних элементов первого уровня вложенности для категорий номенклатуры.  
2.3.  
    2.3.1. Написать текст запроса для отчета (view) «Топ-5 самых покупаемых товаров за последний месяц» (по количеству штук в заказах). В отчете должны быть: Наименование товара, Категория 1-го уровня, Общее количество проданных штук.  
    2.3.2. Проанализировать написанный в п. 2.3.1 запрос и структуру БД. Предложить варианты оптимизации этого запроса и общей схемы данных для повышения производительности системы в условиях роста данных (тысячи заказов в день).  
### 3. Написать сервис «Добавление товара в заказ» который работает по REST-API. Метод должен принимать ID заказа, ID номенклатуры и количество. Если товар уже есть в заказе, его количество должно увеличиваться, а не создаваться новая позиция. Если товара нет в наличии то должна возвращаться соответствующая ошибка. Стек -  любой фреймворк в пределах Python. Git репозиторий, контейнеризация, документация, и прочее — приветствуется.  

![Пример дерева категорий:](/assets/category2.png)  
 Результатом выполнения задания должна быть даталогическая схема данных, SQL запросы по пункту 2 и сервис по пункту 3.



